=TEX
\documentclass[11pt,a4paper]{article}
%\usepackage{latexsym}
\usepackage{ProofPower}
%\usepackage{rbj}
\ftlinepenalty=9999
\usepackage{A4}

\def\ExpName{\mbox{{\sf exp}}}
\def\Exp#1{\ExpName(#1)}
\tabstop=0.4in
\newcommand{\ignore}[1]{}

\title{Strong Infinity for HOL}
\makeindex
\usepackage[unicode,pdftex]{hyperref}
\hypersetup{pdfauthor={Roger Bishop Jones}}
\hypersetup{colorlinks=true, urlcolor=black, citecolor=black, filecolor=black, linkcolor=black}

\author{Roger Bishop Jones}
\date{\ }

\begin{document}
\begin{titlepage}
\maketitle
\begin{abstract}
This document provides a strong axiom of infinity for HOL together with some definitions which facilitate its expression and application.
\end{abstract}


\thispagestyle{empty}
\end{titlepage}
\newpage
\addtocounter{page}{1}
{\parskip=0pt\tableofcontents}

\newpage

\section{INTRODUCTION}

It is the purpose of this document to provide a strong infinity axiom for use with HOL.
This axioms is intended to serve two related purpose.

The first is to provide a basis for embedding mathematical foundation systems such as ZFC and HTT into HOL my methods which are conservative rather than by axiomatisation of such theories in HOL.
The method for doing this is to use the large collection satisfying the strong infinity axiom to provide a model of the target theory, for which purpose a general method of inductive construction is intended to be provided elsewhere.

\section{PRELIMINARIES}

This section is likely to mostly disappear.
It will then contains primarily the concepts which are needed to express the strong infinity axiom, mainly concerning cardinality comparisons.

=SML
open_theory "rbjmisc";
force_new_theory "Ûu002Ý";
new_parent "U_orders";
new_parent "trees";
new_parent "wf_relp";
new_parent "wf_recp";
force_new_pc "Û'u002Ý";
merge_pcs ["'savedthm_cs_¶_proof"] "'u002";
set_merge_pcs ["rbjmisc", "'u002"];
=TEX

The relations defined here with subscript \emph{s} on their names are cardinality comparisons on sets.

=SML
declare_infix(300, "¼‰s");
declare_infix(300, "<‰s");
declare_infix(300, "~‰s");
=TEX

¹HOLCONST
Ü $Û¼‰sÝ : 'a SET ­ 'b SET ­ BOOL
÷üüüüüü
Ü µ A B· A ¼‰s B ¤ ¶f·
Ü	µx y· x  A ± y  A ´ f x  B ± f y  B ± (f x = f y ´ x = y)
°

=GFT
Û¼‰s_reflÝ =
	ô µ A· A ¼‰s A
Û€_¼‰s_thmÝ =
	ô µ A B· A € B ´ A ¼‰s B
Û¼‰s_transÝ =
	ô µ A B C· A ¼‰s B ± B ¼‰s C ´ A ¼‰s C
=TEX

\ignore{
=SML
val ¼‰s_def = get_spec ¬$¼‰s®;

set_goal([], ¬µA:'a ð· A ¼‰s A®);
a (rewrite_tac[¼‰s_def] THEN strip_tac
	THEN ¶_tac ¬Ìx:'a·x®
	THEN rewrite_tac[]);
val ¼‰s_refl = save_pop_thm "¼‰s_refl";

set_goal([], ¬µA B· A € B ´ A ¼‰s B®);
a (rewrite_tac[¼‰s_def, sets_ext_clauses] THEN REPEAT strip_tac);
a (¶_tac ¬Ìx:'a·x® THEN asm_prove_tac[]);
val €_¼‰s_thm = save_pop_thm "€_¼‰s_thm";

set_goal([], ¬µA B C· A ¼‰s B ± B ¼‰s C ´ A ¼‰s C®);
a (rewrite_tac[¼‰s_def] THEN REPEAT strip_tac);
a (¶_tac ¬Ìx· f'(f x)®
	THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac
	THEN (REPEAT_N 3 (TRY (all_asm_ufc_tac[]))));
val ¼‰s_trans = save_pop_thm "¼‰s_trans";

add_pc_thms "'u002" [¼‰s_refl];
set_merge_pcs ["rbjmisc", "'u002"];
=TEX
}%ignore


¹HOLCONST
Ü $Û<‰sÝ : 'a SET ­ 'b SET ­ BOOL
÷üüüüüü
Ü µ A B· A <‰s B ¤ A ¼‰s B ± ³ B ¼‰s A
°

=GFT
Ûlt‰s_irreflÝ =
	ô µ A· ³ A <‰s A
Ûlt‰s_transÝ =
	ô µ A B C· A <‰s B ± B <‰s C ´ A <‰s C
Ûlt‰s_¼‰s_transÝ =
	ô µ A B C· A <‰s B ± B ¼‰s C ´ A <‰s C
Û¼‰s_lt‰s_transÝ =
	ô µ A B C· A ¼‰s B ± B <‰s C ´ A <‰s C
=TEX

\ignore{
=SML
val lt‰s_def = get_spec ¬$<‰s®;

set_goal([], ¬µA:'a ð· ³ A <‰s A®);
a (rewrite_tac[lt‰s_def] THEN REPEAT strip_tac);
val lt‰s_irrefl = save_pop_thm "lt‰s_irrefl";

set_goal([], ¬µA B C· A <‰s B ± B <‰s C ´ A <‰s C®);
a (rewrite_tac[lt‰s_def]
	THEN contr_tac
	THEN all_fc_tac [¼‰s_trans]);
val lt‰s_trans = save_pop_thm "lt‰s_trans";

set_goal([], ¬µA B C· A <‰s B ± B ¼‰s C ´ A <‰s C®);
a (rewrite_tac[lt‰s_def]
	THEN contr_tac
	THEN all_fc_tac [¼‰s_trans]);
val lt‰s_¼‰s_trans = save_pop_thm "lt‰s_¼‰s_trans";

set_goal([], ¬µA B C· A ¼‰s B ± B <‰s C ´ A <‰s C®);
a (rewrite_tac[lt‰s_def]
	THEN contr_tac
	THEN all_fc_tac [¼‰s_trans]);
val ¼‰s_lt‰s_trans = save_pop_thm "¼‰s_lt‰s_trans";
=TEX
}%ignore

¹HOLCONST
Ü $Û~‰sÝ : 'a SET ­ 'b SET ­ BOOL
÷üüüüüü
Ü µ A B·
Ü	A ~‰s B ¤ ¶f g·
Ü		(µx· x  A ´ f x  B ± g (f x) = x)
Ü	±	(µy· y  B ´ g y  A ± f (g y) = y)
°

=GFT
Ûcard_equiv_lemmaÝ =
	ô µ x y z· x ~‰c x ± (x ~‰c y ¤ y ~‰c x) ± (x ~‰c y ± y ~‰c z ´ x ~‰c z)
=TEX

\ignore{
=SML
val eq‰s_def = get_spec ¬$~‰s®;

push_pc "hol";

set_goal([], ¬µx y z· (x ~‰s x)
		± (x ~‰s y ¤ y ~‰s x)
		± (x ~‰s y ± y ~‰s z ´ x ~‰s z)®);
a (rewrite_tac [get_spec ¬$~‰s®] THEN prove_tac[]);
(* *** Goal "1" *** *)
a (¶_tac ¬Ìx:'b· x® THEN ¶_tac ¬Ìx:'b· x® THEN prove_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬f' o f® THEN ¶_tac ¬g o g'® THEN rewrite_tac[o_def]
	THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (REPEAT (asm_fc_tac[]));
(* *** Goal "2.2" *** *)
a (asm_fc_tac[]);
a (spec_nth_asm_tac 5 ¬f x'®);
a (asm_rewrite_tac[]);
(* *** Goal "2.3" *** *)
a (REPEAT_N 2 (asm_fc_tac[]));
(* *** Goal "2.4" *** *)
a (asm_fc_tac[]);
a (spec_nth_asm_tac 6 ¬g' y'®);
a (asm_rewrite_tac[]);
val card_equiv_lemma = save_pop_thm "card_equiv_lemma";

pop_pc();
=TEX
}%ignore

It proves helpful to have this alternative rendering of well-foundedness:

=GFT
Ûlt‰i‰w‰o_wfÝ =
	ô well_founded $<‰i‰w‰o
=TEX

\ignore{
=SML
set_goal ([], ¬well_founded ($<‰i‰w‰o: 'a ­ 'a ­ BOOL)®);
a (LEMMA_T ¬well_founded ($<‰i‰w‰o: 'a ­ 'a ­ BOOL) ¤ WellFounded(Universe, ($<‰i‰w‰o: 'a ­ 'a  ­ BOOL))® rewrite_thm_tac
	THEN1 rewrite_tac 
	[get_spec ¬well_founded®, rewrite_rule [get_spec ¬UWellFounded®] u_well_founded_induction_thm]);
a (rewrite_tac[lt‰i‰w‰o_WFWO_thm]);
val lt‰i‰w‰o_wf = save_pop_thm "lt‰i‰w‰o_wf";
=TEX
}%ignore

=SML
val ÛIWO_INDUCTION_TÝ = WF_INDUCTION_T lt‰i‰w‰o_wf;
val ÛIWO_induction_tacÝ = wf_induction_tac lt‰i‰w‰o_wf;
=TEX

Thinking of the well ordered elements as ordinals, we get a notion of extension.
The extension of an element is the set of elements strictly less than the element. 

¹HOLCONST
Ü ÛX‰i‰w‰oÝ: 'a ­ 'a ð
÷üüüüüüüüüüü
Ü µÂ· X‰i‰w‰o Â = {È | È <‰i‰w‰o Â}
°

=GFT
Ûlt‰i‰w‰o_min_condÝ =
	ô µ A· ³ A = {} ´ (¶ x· x  A ± (µ y· y  A ´ ³ y <‰i‰w‰o x))
Ûlt‰i‰w‰o_transÝ =
	ô µ Â Ç È· Â <‰i‰w‰o Ç ± Ç <‰i‰w‰o È ´ Â <‰i‰w‰o È
Ûlt‰i‰w‰o_irreflÝ =
	ô µ Â· ³ Â <‰i‰w‰o Â
Ûlt‰i‰w‰o_trichÝ =
	ô µ Â Ç· Â <‰i‰w‰o Ç ² Ç <‰i‰w‰o Â ² Â = Ç
Ûlt‰i‰w‰o_trich_fcÝ =
	ô µ Â Ç· ³ Â <‰i‰w‰o Ç ± ³ Ç <‰i‰w‰o Â ´ Â = Ç
Ûlt‰i‰w‰o_trich_fc2Ý =
	ô µ Â Ç· ³ (³ Â <‰i‰w‰o Ç ± ³ Ç <‰i‰w‰o Â ± ³ Â = Ç)
Û¼‰i‰w‰o_reflÝ =
	ô µ Â· Â ¼‰i‰w‰o Â
Û¼‰i‰w‰o_lt‰i‰w‰oÝ =
	ô µ Â Ç· Â ¼‰i‰w‰o Ç ¤ ³ Ç <‰i‰w‰o Â
Û³‰i‰w‰o_clausesÝ =
	ô µ Â Ç· (³ Â <‰i‰w‰o Ç ¤ Ç ¼‰i‰w‰o Â) ± (³ Ç ¼‰i‰w‰o Â ¤ Â <‰i‰w‰o Ç)
=TEX

\ignore{
=SML
val X‰i‰w‰o_def = get_spec ¬X‰i‰w‰o®;

set_goal([], ¬µx y· x  X‰i‰w‰o y ¤ x <‰i‰w‰o y®);
a (rewrite_tac [X‰i‰w‰o_def]);
val X‰i‰w‰o_thm = save_pop_thm "X‰i‰w‰o_thm";

set_goal([], ¬µA:'a SET· ³ A = {} ´ ¶x· x  A ± µy· y  A ´ ³ y <‰i‰w‰o x®);
a (strip_asm_tac lt‰i‰w‰o_WFWO_thm);
a (fc_tac [get_spec ¬WellOrdering®]);
a (fc_tac [get_spec ¬WeakMinCond®]);
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[] THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (¶_tac ¬x'® THEN REPEAT strip_tac);
a (fc_tac [get_spec ¬WellFounded®]);
a (fc_tac [get_spec ¬Irrefl®]);
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[] THEN REPEAT strip_tac);
a (spec_nth_asm_tac 5 ¬y®);
(* *** Goal "1" *** *)
a (var_elim_asm_tac ¬y = x'® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [get_spec ¬LinearOrder®]);
a (fc_tac [get_spec ¬PartialOrder®]);
a (fc_tac [get_spec ¬Antisym®]);
a (POP_ASM_T ante_tac THEN PC_T1 "hol1" rewrite_tac[] THEN contr_tac);
a (contr_tac THEN all_asm_ufc_tac[]);
a (lemma_tac ¬³ x' = y® THEN1 contr_tac);
(* *** Goal "2.1" *** *)
a (var_elim_asm_tac ¬x' = y® THEN asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a (all_asm_fc_tac[]);
val lt‰i‰w‰o_min_cond = save_pop_thm "lt‰i‰w‰o_min_cond";

set_goal([], ¬µÂ Ç È· Â <‰i‰w‰o Ç ± Ç <‰i‰w‰o È ´ Â <‰i‰w‰o È®);
a (strip_asm_tac lt‰i‰w‰o_WFWO_thm);
a (fc_tac [well_ordering_def]);
a (fc_tac [linear_order_def]);
a (fc_tac [partial_order_def]);
a (fc_tac [trans_def]);
a (POP_ASM_T ante_tac
	THEN rewrite_tac[get_spec ¬Universe®]
	THEN REPEAT strip_tac
	THEN all_asm_fc_tac[]);
val lt‰i‰w‰o_trans = save_pop_thm "lt‰i‰w‰o_trans";

set_goal([], ¬µÂ· ³ Â <‰i‰w‰o Â®);
a (strip_asm_tac(lt‰i‰w‰o_WFWO_thm) THEN REPEAT strip_tac);
a (fc_tac [well_founded_def]);
a (fc_tac [irrefl_def]);
a (POP_ASM_T ante_tac THEN rewrite_tac[get_spec¬Universe®]);
a (prove_tac[]);
val lt‰i‰w‰o_irrefl = save_pop_thm "lt‰i‰w‰o_irrefl";

set_goal([], ¬µÂ Ç· Â <‰i‰w‰o Ç ² Ç <‰i‰w‰o Â ² Â = Ç®);
a (strip_asm_tac lt‰i‰w‰o_WFWO_thm);
a (fc_tac [well_ordering_def]);
a (fc_tac [linear_order_def]);
a (fc_tac [trich_def]);
a (POP_ASM_T ante_tac
	THEN rewrite_tac[get_spec ¬Universe®]
	THEN contr_tac
	THEN all_asm_fc_tac[]);
val lt‰i‰w‰o_trich = save_pop_thm "lt‰i‰w‰o_trich";

set_goal([], ¬µÂ Ç· ³ Â <‰i‰w‰o Ç ± ³ Ç <‰i‰w‰o Â ´ Â = Ç®);
a contr_tac;
a (strip_asm_tac (list_µ_elim [¬Â®, ¬Ç®] lt‰i‰w‰o_trich));
val lt‰i‰w‰o_trich_fc = save_pop_thm "lt‰i‰w‰o_trich_fc";

set_goal([], ¬µÂ Ç· ³ (³ Â <‰i‰w‰o Ç ± ³ Ç <‰i‰w‰o Â ± ³ Â = Ç)®);
a contr_tac;
a (strip_asm_tac (list_µ_elim [¬Â®, ¬Ç®] lt‰i‰w‰o_trich));
val lt‰i‰w‰o_trich_fc2 = save_pop_thm "lt‰i‰w‰o_trich_fc2";

set_goal([], ¬µÂ· Â ¼‰i‰w‰o Â®);
a (rewrite_tac[¼‰i‰w‰o_def]);
val ¼‰i‰w‰o_refl = save_pop_thm "¼‰i‰w‰o_refl";

set_goal([], ¬µÂ Ç· Â ¼‰i‰w‰o Ç ¤ ³ Ç <‰i‰w‰o Â®);
a (REPEAT µ_tac THEN rewrite_tac [¼‰i‰w‰o_def]);
a (contr_tac
	THEN strip_asm_tac (list_µ_elim [¬Â®, ¬Ç®] lt‰i‰w‰o_trich)
	THEN all_fc_tac [lt‰i‰w‰o_trans]
	THEN_TRY var_elim_nth_asm_tac 2
	THEN fc_tac[lt‰i‰w‰o_irrefl]);
val ¼‰i‰w‰o_lt‰i‰w‰o = save_pop_thm "¼‰i‰w‰o_lt‰i‰w‰o";

set_goal([], ¬µÂ Ç· (³ Â <‰i‰w‰o Ç ¤ Ç ¼‰i‰w‰o Â)
	±  (³ Ç ¼‰i‰w‰o Â ¤ Â <‰i‰w‰o Ç)®);
a (rewrite_tac[¼‰i‰w‰o_def] THEN contr_tac
	THEN_TRY all_var_elim_asm_tac
	THEN_TRY all_fc_tac [lt‰i‰w‰o_trich_fc, lt‰i‰w‰o_trans]
	THEN asm_prove_tac [lt‰i‰w‰o_irrefl]);
val ³‰i‰w‰o_clauses = save_pop_thm "³‰i‰w‰o_clauses";

add_rw_thms [X‰i‰w‰o_thm, lt‰i‰w‰o_irrefl, ¼‰i‰w‰o_refl] "'u002";
add_sc_thms [X‰i‰w‰o_thm, lt‰i‰w‰o_irrefl, ¼‰i‰w‰o_refl] "'u002";
add_st_thms [X‰i‰w‰o_thm, lt‰i‰w‰o_irrefl] "'u002";
set_merge_pcs ["basic_hol", "'u002"];
=TEX
}%ignore

A useful principle for reasoning about the elements of a well-ordering is the following analogue of set theoretic extensionality:

=GFT
Ûlt‰i‰w‰o_ext_thmÝ =
	ô µ Â Ç· Â = Ç ¤ (µ Ä· Ä <‰i‰w‰o Â ¤ Ä <‰i‰w‰o Ç)
=TEX

We we later make use of quasi extensional characterisations of operations over well orderings, in which an expression is characterised by a statement of the conditions under which elements are less than the value of the expression.
This facilitates proofs about well orderings in which the complexity is on the right of an inequality, or in which such can be obtained by the extensionality principle above.

This leaves an awkwardness where our goal has an expression on the left of an inequality which the following rule is intended to ameliorate.

=GFT
Û¼‰i‰w‰o_ext_thmÝ =
	ô µ Â Ç· Â ¼‰i‰w‰o Ç ¤ (µ Ä· Ä <‰i‰w‰o Â ´ Ä <‰i‰w‰o Ç)
=TEX

\ignore{
=SML
set_goal([], ¬µÂ Ç· Â = Ç ¤ µÄ· Ä <‰i‰w‰o Â ¤ Ä <‰i‰w‰o Ç®);
a (REPEAT_N 5 strip_tac THEN_TRY asm_rewrite_tac[] THEN contr_tac);
a (spec_nth_asm_tac 2 ¬Â®
	THEN spec_nth_asm_tac 4 ¬Ç®
	THEN all_fc_tac [lt‰i‰w‰o_trich_fc2]);
val lt‰i‰w‰o_ext_thm = save_pop_thm "lt‰i‰w‰o_ext_thm";

(* skip to end of next section for ¼‰i‰w‰o_ext_thm *)
=TEX
}%ignore

=GFT
Ûlt‰i‰w‰o_¼‰i‰w‰oÝ =
	ô µ Â Ç È· Â <‰i‰w‰o Ç ´ Â ¼‰i‰w‰o Ç
Û¼‰i‰w‰o_transÝ =
	ô µ Â Ç È· Â ¼‰i‰w‰o Ç ± Ç ¼‰i‰w‰o È ´ Â ¼‰i‰w‰o È
Û¼‰i‰w‰o_lt‰i‰w‰o_transÝ =
	ô µ Â Ç È· Â ¼‰i‰w‰i‰w‰o Ç ± Ç <‰i‰w‰o È ´ Â <‰i‰w‰o È
Ûlt‰i‰w‰o_¼‰i‰w‰o_transÝ =
	ô µ Â Ç È· Â <‰i‰w‰o Ç ± Ç ¼‰i‰w‰o È ´ Â <‰i‰w‰o È
Û¼‰i‰w‰o_casesÝ =
	ô µ Â Ç· Â ¼‰i‰w‰o Ç ² Ç ¼‰i‰w‰o Â
=TEX

\ignore{
=SML
set_goal([], ¬µ Â Ç È· Â <‰i‰w‰o Ç ´ Â ¼‰i‰w‰o Ç®);
a (rewrite_tac[¼‰i‰w‰o_def] THEN REPEAT strip_tac);
val lt‰i‰w‰o_¼‰i‰w‰o = save_pop_thm "lt‰i‰w‰o_¼‰i‰w‰o";

set_goal([], ¬µÂ Ç È· Â ¼‰i‰w‰o Ç ± Ç ¼‰i‰w‰o È ´ Â ¼‰i‰w‰o È®);
a (rewrite_tac[¼‰i‰w‰o_def] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN all_fc_tac [lt‰i‰w‰o_trans]
	THEN rewrite_tac[]);
val ¼‰i‰w‰o_trans = save_pop_thm "¼‰i‰w‰o_trans";

set_goal([], ¬µÂ Ç È· Â ¼‰i‰w‰o Ç ± Ç <‰i‰w‰o È ´ Â <‰i‰w‰o È®);
a (rewrite_tac[¼‰i‰w‰o_def] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN all_fc_tac [lt‰i‰w‰o_trans]
	THEN rewrite_tac[]);
val ¼‰i‰w‰o_lt‰i‰w‰o_trans = save_pop_thm "¼‰i‰w‰o_lt‰i‰w‰o_trans";

set_goal([], ¬µÂ Ç È· Â <‰i‰w‰o Ç ± Ç ¼‰i‰w‰o È ´ Â <‰i‰w‰o È®);
a (rewrite_tac[¼‰i‰w‰o_def] THEN REPEAT strip_tac
	THEN_TRY all_var_elim_asm_tac
	THEN all_fc_tac [lt‰i‰w‰o_trans]
	THEN rewrite_tac[]);
val lt‰i‰w‰o_¼‰i‰w‰o_trans = save_pop_thm "lt‰i‰w‰o_¼‰i‰w‰o_trans";

set_goal([], ¬µÂ Ç· Â ¼‰i‰w‰o Ç ² Ç ¼‰i‰w‰o Â®);
a (rewrite_tac[¼‰i‰w‰o_def] THEN contr_tac);
a (strip_asm_tac (all_µ_elim lt‰i‰w‰o_trich));
val ¼‰i‰w‰o_cases = save_pop_thm "¼‰i‰w‰o_cases";

set_goal([], ¬µÂ Ç· Â ¼‰i‰w‰o Ç ¤ µÄ· Ä <‰i‰w‰o Â ´ Ä <‰i‰w‰o Ç®);
a (REPEAT_N 5 strip_tac THEN_TRY asm_rewrite_tac[] THEN contr_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [lt‰i‰w‰o_¼‰i‰w‰o_trans]);
(* *** Goal "2" *** *)
a (spec_nth_asm_tac 2 ¬Ç®);
a (REPEAT_N 2 (POP_ASM_T ante_tac)
	THEN rewrite_tac[³‰i‰w‰o_clauses]
	THEN REPEAT strip_tac);
val ¼‰i‰w‰o_ext_thm = save_pop_thm "¼‰i‰w‰o_ext_thm";
=TEX
}%ignore

It will be useful to have a name for the least element of a collection in a well-ordering.

\ignore{
=SML
set_goal([], ¬¶Least‰i‰w‰o· µso· 
	µÈ· È  so ´ Least‰i‰w‰o so  so ± Least‰i‰w‰o so ¼‰i‰w‰o È®);
a (¶_tac ¬Ìso· ÅÇ· Ç  so ± µÂ· Â  so ´ Ç ¼‰i‰w‰o Â®
	THEN rewrite_tac[]
	THEN REPEAT_N 3 strip_tac);
a (Å_tac ¬Å Ç· Ç  so ± (µ Â· Â  so ´ Ç ¼‰i‰w‰o Â)®);
(* *** Goal "1" *** *)
a (strip_asm_tac (µ_elim ¬so® lt‰i‰w‰o_min_cond));
(* *** Goal "1.1" *** *)
a (PC_T1 "hol1" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a (¶_tac ¬x®
	THEN asm_rewrite_tac []
	THEN µ_tac
	THEN asm_rewrite_tac[get_spec ¬$¼‰i‰w‰o®]
	THEN contr_tac
	THEN asm_fc_tac[]);
a (strip_asm_tac (list_µ_elim [¬x®, ¬Â®] lt‰i‰w‰o_trich));
(* *** Goal "2" *** *)
a (ASM_FC_T asm_rewrite_tac[]);
save_cs_¶_thm (pop_thm());
=TEX
}%ignore

¹HOLCONST
Ü ÛLeast‰i‰w‰oÝ: 'a ð ­ 'a
÷üüüüüüüüüüü
Ü µso È· È  so ´ Least‰i‰w‰o so  so ± Least‰i‰w‰o so ¼‰i‰w‰o È
°

... and for the supremum of a set:

¹HOLCONST
Ü ÛUb‰i‰w‰oÝ: 'a ð ­ 'a ð
÷üüüüüüüüüüü
Ü µso· Ub‰i‰w‰o so = {Â | µÈ· È  so ´ È ¼‰i‰w‰o Â}
°

¹HOLCONST
Ü ÛSUb‰i‰w‰oÝ: 'a ð ­ 'a ð
÷üüüüüüüüüüü
Ü µso· SUb‰i‰w‰o so = {Â | µÈ· È  so ´ È <‰i‰w‰o Â}
°

¹HOLCONST
Ü ÛSup‰i‰w‰oÝ: 'a ð ­ 'a
÷üüüüüüüüüüü
Ü µso· Sup‰i‰w‰o so = Least‰i‰w‰o (Ub‰i‰w‰o so)
°

¹HOLCONST
Ü ÛSSup‰i‰w‰oÝ: 'a ð ­ 'a
÷üüüüüüüüüüü
Ü µso· SSup‰i‰w‰o so = Least‰i‰w‰o (SUb‰i‰w‰o so)
°

=GFT
ÛLeast‰i‰w‰o_thmÝ =
	ô µ so Â· Â  so ´
		(µ Ç· Ç <‰i‰w‰o Least‰i‰w‰o so ¤ (µ È· È  so ´ Ç <‰i‰w‰o È))
ÛUb‰i‰w‰o_thmÝ =
	ô µ so Ç· Ç  Ub‰i‰w‰o so ¤ (µ È· È  so ´ È ¼‰i‰w‰o Ç)
ÛUb‰i‰w‰o_X‰i‰w‰o_thmÝ =
	ô µ Á· Á  Ub‰i‰w‰o (X‰i‰w‰o Á)
ÛUb‰i‰w‰o_X‰i‰w‰o_thm2Ý =
	ô µ Á· Á  Ub‰i‰w‰o {Â|Â <‰i‰w‰o Á}
ÛSUb‰i‰w‰o_thmÝ =
	ô µ so Ç· Ç  SUb‰i‰w‰o so ¤ (µ È· È  so ´ È <‰i‰w‰o Ç)
ÛSUb‰i‰w‰o_X‰i‰w‰o_thmÝ =
	ô µ Á· Á  SUb‰i‰w‰o (X‰i‰w‰o Á)
ÛSUb‰i‰w‰o_X‰i‰w‰o_thm2Ý =
	ô µ Á· Á  SUb‰i‰w‰o {Â|Â <‰i‰w‰o Á}
Ûlt‰i‰w‰o_Sup‰i‰w‰oÝ =
	ô µ so Á· Á  Ub‰i‰w‰o so ´
		(µÇ· Ç <‰i‰w‰o Sup‰i‰w‰o so ¤ (¶È· È  so ± Ç <‰i‰w‰o È))
Ûlt‰i‰w‰o_Sup‰i‰w‰o2Ý =
	ô µ Á Ç· Ç <‰i‰w‰o Sup‰i‰w‰o {Â|Â <‰i‰w‰o Á} ¤ (¶ È· È <‰i‰w‰o Á ± Ç <‰i‰w‰o È)
Ûlt‰i‰w‰o_SSup‰i‰w‰oÝ =
	ô µ so Á· Á  SUb‰i‰w‰o so ´
		(µ Ç· Ç <‰i‰w‰o SSup‰i‰w‰o so ¤ (¶ È· È  so ± Ç ¼‰i‰w‰o È))
ÛSSup‰i‰w‰o_lt‰i‰w‰oÝ =
	ô µ Á· SSup‰i‰w‰o {Â|Â <‰i‰w‰o Á} = Á
ÛSSup‰i‰w‰o_lt‰i‰w‰o2Ý =
	ô µ so Á Â· Â  so ± Â  SUb‰i‰w‰o so ´
		(SSup‰i‰w‰o so <‰i‰w‰o Á ¤ (¶ Â· Â  SUb‰i‰w‰o so ± Â <‰i‰w‰o Á))
ÛSSup‰i‰w‰o_X‰i‰w‰oÝ =
	ô µ Á· SSup‰i‰w‰o (X‰i‰w‰o Á) = Á
=TEX

\ignore{
=SML
val Least‰i‰w‰o_def = get_spec ¬Least‰i‰w‰o®;
val Ub‰i‰w‰o_def = get_spec ¬Ub‰i‰w‰o®;
val SUb‰i‰w‰o_def = get_spec ¬SUb‰i‰w‰o®;
val Sup‰i‰w‰o_def = get_spec ¬Sup‰i‰w‰o®;
val SSup‰i‰w‰o_def = get_spec ¬SSup‰i‰w‰o®;

push_pc "hol1";

set_goal([], ¬µso Â· Â  so ´
	(µÇ· Ç <‰i‰w‰o Least‰i‰w‰o so ¤ µÈ· È  so ´ Ç <‰i‰w‰o È)®);
a (REPEAT strip_tac THEN all_ufc_tac [Least‰i‰w‰o_def]);
(* *** Goal "1" *** *)
a (all_fc_tac[lt‰i‰w‰o_¼‰i‰w‰o_trans]);
(* *** Goal "2" *** *)
a (asm_fc_tac[]);
val Least‰i‰w‰o_thm = save_pop_thm "Least‰i‰w‰o_thm";

set_goal([], ¬µso Ç· Ç  Ub‰i‰w‰o so ¤ µÈ· È  so ´ È ¼‰i‰w‰o Ç®);
a (rewrite_tac[Ub‰i‰w‰o_def]);
val Ub‰i‰w‰o_thm = save_pop_thm "Ub‰i‰w‰o_thm";

set_goal([], ¬µÁ· Á  Ub‰i‰w‰o (X‰i‰w‰o Á)®);
a (strip_tac THEN rewrite_tac[Ub‰i‰w‰o_thm, X‰i‰w‰o_def, ¼‰i‰w‰o_def]
	THEN REPEAT strip_tac);
val Ub‰i‰w‰o_X‰i‰w‰o_thm = save_pop_thm "Ub‰i‰w‰o_X‰i‰w‰o_thm";

set_goal([], ¬µÁ· Á  Ub‰i‰w‰o {Â | Â <‰i‰w‰o Á}®);
a (strip_tac THEN rewrite_tac[Ub‰i‰w‰o_thm, ¼‰i‰w‰o_def]
	THEN REPEAT strip_tac);
val Ub‰i‰w‰o_X‰i‰w‰o_thm2 = save_pop_thm "Ub‰i‰w‰o_X‰i‰w‰o_thm2";

set_goal([], ¬µso Ç· Ç  SUb‰i‰w‰o so ¤ µÈ· È  so ´ È <‰i‰w‰o Ç®);
a (rewrite_tac[SUb‰i‰w‰o_def]);
val SUb‰i‰w‰o_thm = save_pop_thm "SUb‰i‰w‰o_thm";

set_goal([], ¬µÁ· Á  SUb‰i‰w‰o (X‰i‰w‰o Á)®);
a (strip_tac THEN rewrite_tac[SUb‰i‰w‰o_thm, X‰i‰w‰o_def, ¼‰i‰w‰o_def]
	THEN REPEAT strip_tac);
val SUb‰i‰w‰o_X‰i‰w‰o_thm = save_pop_thm "SUb‰i‰w‰o_X‰i‰w‰o_thm";

set_goal([], ¬µÁ· Á  SUb‰i‰w‰o {Â | Â <‰i‰w‰o Á}®);
a (strip_tac THEN rewrite_tac[SUb‰i‰w‰o_thm, ¼‰i‰w‰o_def]
	THEN REPEAT strip_tac);
val SUb‰i‰w‰o_X‰i‰w‰o_thm2 = save_pop_thm "SUb‰i‰w‰o_X‰i‰w‰o_thm2";

set_goal([], ¬µso Á· Á  Ub‰i‰w‰o so ´
	(µÇ· Ç <‰i‰w‰o Sup‰i‰w‰o so ¤ ¶È· È  so ± Ç <‰i‰w‰o È)®);
a (rewrite_tac[Sup‰i‰w‰o_def]
	THEN REPEAT_N 5 strip_tac
	THEN_TRY all_ufc_¤_rewrite_tac [Least‰i‰w‰o_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (contr_tac);
a (lemma_tac ¬Ç  Ub‰i‰w‰o so®);
(* *** Goal "1.1" *** *)
a (asm_rewrite_tac [Ub‰i‰w‰o_thm]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬È®);
a (asm_rewrite_tac[¼‰i‰w‰o_lt‰i‰w‰o]);
(* *** Goal "1.2" *** *)
a (asm_fc_tac[]);
a (fc_tac[lt‰i‰w‰o_irrefl]);
(* *** Goal "2" *** *)
a (all_fc_tac[Ub‰i‰w‰o_thm]);
a (all_fc_tac[lt‰i‰w‰o_¼‰i‰w‰o_trans]);
val lt‰i‰w‰o_Sup‰i‰w‰o = save_pop_thm "lt‰i‰w‰o_Sup‰i‰w‰o";

=IGN
set_goal([], ¬µso1 so2 Á· Á  Ub‰i‰w‰o so2 ± so1 € so2
	´ Sup‰i‰w‰o so1 ¼‰i‰w‰o Sup‰i‰w‰o so2®);
a (REPEAT strip_tac THEN rewrite_tac[]);
=SML

set_goal([], ¬µÁ Ç· Ç <‰i‰w‰o Sup‰i‰w‰o {Â | Â <‰i‰w‰o Á} ¤ ¶È· È <‰i‰w‰o Á ± Ç <‰i‰w‰o È®);
a (REPEAT µ_tac);
a (lemma_tac ¬¶ È· È  Ub‰i‰w‰o {Â|Â <‰i‰w‰o Á}®
	THEN1 (¶_tac ¬Á:'a® THEN rewrite_tac[Ub‰i‰w‰o_X‰i‰w‰o_thm2]));
a (all_ufc_¤_tac[lt‰i‰w‰o_Sup‰i‰w‰o]);
a (asm_rewrite_tac[]);
val lt‰i‰w‰o_Sup‰i‰w‰o2 = save_pop_thm "lt‰i‰w‰o_Sup‰i‰w‰o2";

=IGN
set_goal([], ¬µso· (¶Á· Á  Ub‰i‰w‰o so) ´
	µÇ· Sup‰i‰w‰o so <‰i‰w‰o Ç ¤ ¶È· È  Ub‰i‰w‰o so ´ È <‰i‰w‰o Ç®);
a (rewrite_tac[Sup‰i‰w‰o_def]
	THEN REPEAT_N 5 strip_tac);
	THEN_TRY all_ufc_¤_rewrite_tac [Least‰i‰w‰o_thm]
	THEN REPEAT strip_tac);
=SML

pop_pc();
set_merge_pcs ["rbjmisc", "'u002"];

set_goal([], ¬µso Á· Á  SUb‰i‰w‰o so ´
	(µÇ· Ç <‰i‰w‰o SSup‰i‰w‰o so ¤ ¶È· È  so ± Ç ¼‰i‰w‰o È)®);
a (rewrite_tac[SSup‰i‰w‰o_def]
	THEN REPEAT_N 5 strip_tac
	THEN_TRY all_ufc_¤_rewrite_tac [Least‰i‰w‰o_thm]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (contr_tac);
a (lemma_tac ¬Ç  SUb‰i‰w‰o so®);
(* *** Goal "1.1" *** *)
a (asm_rewrite_tac [SUb‰i‰w‰o_thm]
	THEN REPEAT strip_tac);
a (spec_nth_asm_tac 2 ¬È®);
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac[¼‰i‰w‰o_lt‰i‰w‰o]);
(* *** Goal "1.2" *** *)
a (asm_fc_tac[]);
(* *** Goal "2" *** *)
a (all_fc_tac[SUb‰i‰w‰o_thm]);
a (all_fc_tac[¼‰i‰w‰o_lt‰i‰w‰o_trans]);
val lt‰i‰w‰o_SSup‰i‰w‰o = save_pop_thm "lt‰i‰w‰o_SSup‰i‰w‰o";

set_goal([], ¬µÁ· SSup‰i‰w‰o {Â | Â <‰i‰w‰o Á} = Á®);
a (REPEAT µ_tac THEN once_rewrite_tac[lt‰i‰w‰o_ext_thm]);
a (lemma_tac ¬¶ È· È  SUb‰i‰w‰o {Â|Â <‰i‰w‰o Á}®
	THEN1 (¶_tac ¬Á:'a® THEN rewrite_tac[SUb‰i‰w‰o_X‰i‰w‰o_thm2]));
a (all_ufc_¤_tac[lt‰i‰w‰o_SSup‰i‰w‰o]);
a (asm_rewrite_tac[]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_fc_tac [¼‰i‰w‰o_lt‰i‰w‰o_trans]);
(* *** Goal "2" *** *)
a (¶_tac ¬Ä® THEN asm_rewrite_tac[]);
val SSup‰i‰w‰o_lt‰i‰w‰o = save_pop_thm "SSup‰i‰w‰o_lt‰i‰w‰o";

set_goal([], ¬µÁ· SSup‰i‰w‰o (X‰i‰w‰o Á) = Á®);
a (strip_tac THEN rewrite_tac[X‰i‰w‰o_def, SSup‰i‰w‰o_lt‰i‰w‰o]);
val SSup‰i‰w‰o_X‰i‰w‰o = save_pop_thm "SSup‰i‰w‰o_X‰i‰w‰o";

set_goal([], ¬µso Â Ç· Â  so ± Ç  SUb‰i‰w‰o so ´
	(µÁ· SSup‰i‰w‰o so <‰i‰w‰o Á ¤ ¶È· È  SUb‰i‰w‰o so ± È <‰i‰w‰o Á)®);
a (REPEAT µ_tac THEN rewrite_tac[SSup‰i‰w‰o_def]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_ufc_¤_tac [Least‰i‰w‰o_def]);
a (¶_tac ¬Least‰i‰w‰o (SUb‰i‰w‰o so)® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (all_ufc_¤_tac [Least‰i‰w‰o_def]);
a (all_ufc_tac [¼‰i‰w‰o_lt‰i‰w‰o_trans]);
val SSup‰i‰w‰o_lt‰i‰w‰o2 = save_pop_thm "SSup‰i‰w‰o_lt‰i‰w‰o2";

=IGN
set_goal([], ¬µÇ P· (¶È· È  SUb‰i‰w‰o {Â | P Â Ç}) ± (µÂ· Â <‰i‰w‰o Ç ¤ P Â Ç)
	´ Ç = SSup‰i‰w‰o{Â | P Â Ç}®);
a (rewrite_tac[lt‰i‰w‰o_ext_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (all_ufc_¤_rewrite_tac [lt‰i‰w‰o_SSup‰i‰w‰o]);
a (¶_tac ¬Ä® THEN all_asm_fc_tac[] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a (POP_ASM_T ante_tac
	THEN all_ufc_¤_rewrite_tac [lt‰i‰w‰o_SSup‰i‰w‰o]
	THEN strip_tac);
a (DROP_NTH_ASM_T 2 ante_tac
	THEN SYM_ASMS_T rewrite_tac
	THEN strip_tac);
a (all_fc_tac [¼‰i‰w‰o_lt‰i‰w‰o_trans]);
val 

=SML
add_rw_thms [Ub‰i‰w‰o_thm, SUb‰i‰w‰o_thm, Ub‰i‰w‰o_X‰i‰w‰o_thm, SUb‰i‰w‰o_X‰i‰w‰o_thm,
	Ub‰i‰w‰o_X‰i‰w‰o_thm2, SUb‰i‰w‰o_X‰i‰w‰o_thm2, lt‰i‰w‰o_Sup‰i‰w‰o2, SSup‰i‰w‰o_lt‰i‰w‰o, SSup‰i‰w‰o_X‰i‰w‰o] "'u002";
add_sc_thms [Ub‰i‰w‰o_thm, SUb‰i‰w‰o_thm, Ub‰i‰w‰o_X‰i‰w‰o_thm, SUb‰i‰w‰o_X‰i‰w‰o_thm,
	Ub‰i‰w‰o_X‰i‰w‰o_thm2, SUb‰i‰w‰o_X‰i‰w‰o_thm2, lt‰i‰w‰o_Sup‰i‰w‰o2, SSup‰i‰w‰o_lt‰i‰w‰o, SSup‰i‰w‰o_X‰i‰w‰o] "'u002";
add_st_thms [lt‰i‰w‰o_Sup‰i‰w‰o2] "'u002";
set_merge_pcs ["rbjmisc1", "'u002"];
=TEX
}%ignore

Now a name to the least 'a:

¹HOLCONST
Ü Û0‰i‰w‰oÝ: 'a
÷üüüüüüüüüüü
Ü 0‰i‰w‰o = Least‰i‰w‰o {Ä | T}
°

=GFT
Ûzero‰i‰w‰o_thmÝ =
	ô µ Â· 0‰i‰w‰o ¼‰i‰w‰o Â
Ûlt‰i‰w‰o_zero‰i‰w‰o_thmÝ =
	ô µ Â· ³ Â <‰i‰w‰o 0‰i‰w‰o
=TEX

\ignore{
=SML
val zero‰i‰w‰o_def = get_spec ¬0‰i‰w‰o®;

set_goal([], ¬µÂ· 0‰i‰w‰o ¼‰i‰w‰o Â®);
a (rewrite_tac[zero‰i‰w‰o_def, pc_rule1 "hol1" rewrite_rule []
	(µ_elim ¬{Ä:'a|T}® Least‰i‰w‰o_def)]
	THEN strip_tac);
val zero‰i‰w‰o_thm = save_pop_thm "zero‰i‰w‰o_thm";

val lt‰i‰w‰o_zero‰i‰w‰o_thm = save_thm ("lt‰i‰w‰o_zero‰i‰w‰o_thm",
	rewrite_rule [¼‰i‰w‰o_lt‰i‰w‰o] zero‰i‰w‰o_thm);
=TEX
}%ignore

In order to define operators over the 'as (without undesirable complications) the 'as must be closed under the operations.
If we want to use such operations in formulating our strong axiom of infinity, then we would need to assert sufficiently strong closure conditions in advance of our axiom of infinity.

The basis for the closure principle one which definitions of functions like 'a addition is based is a related to the axiom of replacement in set theory.
In talking of 'as the corresponding notion is that or regularity, which we can define without any kind of axiom of infinity as follows.

First the notion of cofinality.
This definition is perhaps a little eccentric, in that it is defined over all 'as not just limit 'as, and in that it is couched in terms of arbitrary functions rather than increasing sequences, and consequently takes the supremum of the image rather than the limit of a sequence.

The supremum of an image will prove more generally useful so we give it a name.

By the image of an 'a through a map, I mean the image of the set of 'as less than that 'a ():

¹HOLCONST
Ü ÛImage‰i‰w‰oÝ: (('a ­ 'b) ¸ 'a) ­ 'b ð
÷üüüüüüüüüüü
Ü µf Â· Image‰i‰w‰o(f, Â) = {Ä | ¶È· È <‰i‰w‰o Â ± f È = Ä}
°

=GFT
ÛImage‰i‰w‰o_thmÝ =
	ô µ f Â Ç· Ç  Image‰i‰w‰o (f, Â) ¤ (¶ È· È <‰i‰w‰o Â ± Ç = f È)
ÛImage‰i‰w‰o_zero‰i‰w‰o_thmÝ =
	ô µ f· Image‰i‰w‰o (f, 0‰i‰w‰o) = {}
ÛImage‰i‰w‰o_mono_thmÝ =
	ô µ f Á Â· Á ¼‰i‰w‰o Â ´ Image‰i‰w‰o (f, Á) € Image‰i‰w‰o (f, Â)
=IGN
ÛUb‰i‰w‰o_Image‰i‰w‰o_thmÝ =
	ô µ f Â· ¶ Ç· Ç  Ub‰i‰w‰o (Image‰i‰w‰o (f, Â))
ÛUb‰i‰w‰o_Image‰i‰w‰o_zero‰i‰w‰oÝ =
	ô µ f Â Ç· Ç  Ub‰i‰w‰o (Image‰i‰w‰o (f, 0‰i‰w‰o))
ÛSUb‰i‰w‰o_Image‰i‰w‰o_thmÝ =
	ô µ f Â· ¶ Ç· Ç  SUb‰i‰w‰o (Image‰i‰w‰o (f, Â))
ÛSUb‰i‰w‰o_Image‰i‰w‰o_zero‰i‰w‰oÝ =
	ô µ f Â Ç· Ç  SUb‰i‰w‰o (Image‰i‰w‰o (f, 0‰i‰w‰o))
=TEX

\ignore{
=SML
val Image‰i‰w‰o_def = get_spec ¬Image‰i‰w‰o®;

set_goal([], ¬µf Â Ç· Ç  Image‰i‰w‰o (f, Â) ¤ ¶È· È <‰i‰w‰o Â ± Ç = f È®);
a (rewrite_tac[Image‰i‰w‰o_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬È® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (¶_tac ¬È® THEN asm_rewrite_tac[]);
val Image‰i‰w‰o_thm = save_pop_thm "Image‰i‰w‰o_thm";

set_goal([], ¬µf:'b ­ 'a· Image‰i‰w‰o(f, 0‰i‰w‰o) = {}®);
a (strip_tac THEN rewrite_tac[sets_ext_clauses, Image‰i‰w‰o_thm, lt‰i‰w‰o_zero‰i‰w‰o_thm]);
val Image‰i‰w‰o_zero‰i‰w‰o_thm = save_pop_thm "Image‰i‰w‰o_zero‰i‰w‰o_thm";

set_goal([], ¬µf Á Â· Á ¼‰i‰w‰o Â ´ Image‰i‰w‰o(f, Á) € Image‰i‰w‰o(f, Â)®);
a (rewrite_tac[Image‰i‰w‰o_thm, lt‰i‰w‰o_zero‰i‰w‰o_thm]
	THEN REPEAT strip_tac);
a (¶_tac ¬È® THEN asm_rewrite_tac[]);
a (all_fc_tac[lt‰i‰w‰o_¼‰i‰w‰o_trans]);
val Image‰i‰w‰o_mono_thm = save_pop_thm "Image‰i‰w‰o_mono_thm";


=SML
add_rw_thms [Image‰i‰w‰o_thm, zero‰i‰w‰o_thm, lt‰i‰w‰o_zero‰i‰w‰o_thm] "'u002";
add_sc_thms [Image‰i‰w‰o_thm, zero‰i‰w‰o_thm, lt‰i‰w‰o_zero‰i‰w‰o_thm] "'u002";
add_st_thms [Image‰i‰w‰o_thm, lt‰i‰w‰o_zero‰i‰w‰o_thm] "'u002";
set_merge_pcs ["rbjmisc", "'u002"];
=TEX
}%ignore


$SupIm‰o$ is then the supremum of the image of an 'a.
In the case that the function is increasing then this is the limit of a $Â$ sequence.
Sometimes where such a limit is used in the literature there is no apparent benefit from the restriction to increasing sequences and I use $SupIm‰i‰w‰o$ of an arbitary map, as in, for example, the definition of 'a addition.

¹HOLCONST
Ü ÛSupIm‰i‰w‰oÝ: (('a ­ 'a) ¸ 'a) ­ 'a
÷üüüüüüüüüüü
Ü µx· SupIm‰i‰w‰o x = Sup‰i‰w‰o (Image‰i‰w‰o x)
°

$SSupIm‰i‰w‰o$ is the strict supremum of the image of an 'a.

¹HOLCONST
Ü ÛSSupIm‰i‰w‰oÝ: (('a ­ 'a) ¸ 'a) ­ 'a
÷üüüüüüüüüüü
Ü µx· SSupIm‰i‰w‰o x = SSup‰i‰w‰o (Image‰i‰w‰o x)
°

In general the supremum of an image only exists if the image is bounded above.
However, one of the principle purposes of our axiom of strong infinity is to ensure that such bounds exist.
By analogy with replacement in set theory, which tells us that the image of a set is a set, we know that the image of a bounded collection of 'as is itself bounded.
This enables us to prove the following results about $SupIm‰o$ and $SSupIm‰o$.

=GFT
Ûlt‰i‰w‰o_SupIm‰oÝ =
	ô µ f Â Ç· Ç <‰i‰w‰o SupIm‰i‰w‰o (f, Â) ¤ (¶ È· È <‰i‰w‰o Â ± Ç <‰i‰w‰o f È)
ÛSupIm‰o_zero‰i‰w‰oÝ =
	ô µ f Â Ç· ³ Ç <‰i‰w‰o SupIm‰i‰w‰o (f, 0‰i‰w‰o)
Ûlt‰i‰w‰o_SSupIm‰oÝ =
	ô µ f Â Ç· Ç <‰i‰w‰o SSupIm‰i‰w‰o (f, Â) ¤ (¶ È· È <‰i‰w‰o Â ± Ç ¼‰i‰w‰o f È)
ÛSSupIm‰o_zero‰i‰w‰oÝ =
	ô µ f Â Ç· ³ Ç <‰i‰w‰o SSupIm‰i‰w‰o (f, 0‰i‰w‰o)
=TEX

\ignore{
=SML
val SupIm‰i‰w‰o_def = get_spec ¬SupIm‰i‰w‰o®;
val SSupIm‰i‰w‰o_def = get_spec ¬SSupIm‰i‰w‰o®;
=IGN
set_goal([], ¬µf Á Â· Á ¼‰i‰w‰o Â ´ SupIm‰o (f, Á) ¼‰i‰w‰o SupIm‰o (f, Â)®);
a (REPEAT µ_tac THEN rewrite_tac[SupIm‰o_def] THEN REPEAT strip_tac);
 =SML

set_goal([], ¬µf Â Ç· Ç <‰i‰w‰o SSupIm‰o (f, Â) ¤ ¶È· È <‰i‰w‰o Â ± Ç ¼‰i‰w‰o f È®);
a (REPEAT µ_tac
	THEN rewrite_tac [SSupIm‰o_def]);
a (strip_asm_tac (list_µ_elim [¬f®, ¬Â®] SUb‰i‰w‰o_Image‰i‰w‰o_thm));
a (all_ufc_¤_rewrite_tac [µ_elim ¬Image‰i‰w‰o (f, Â)® lt‰i‰w‰o_SSup‰i‰w‰o]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬$"È'"® THEN asm_rewrite_tac[]);
a (SYM_ASMS_T rewrite_tac);
(* *** Goal "2" *** *)
a (¶_tac ¬f È® THEN asm_rewrite_tac[Image‰i‰w‰o_thm]);
a (¶_tac ¬È® THEN asm_rewrite_tac[]);
val lt‰i‰w‰o_SSupIm‰o = save_pop_thm "lt‰i‰w‰o_SSupIm‰o";

set_goal([], ¬µf· SSupIm‰o (f, 0‰i‰w‰o) = 0‰i‰w‰o®);
a (rewrite_tac[lt‰i‰w‰o_ext_thm, lt‰i‰w‰o_SSupIm‰o]);
val SSupIm‰o_zero‰i‰w‰o = save_pop_thm "SSupIm‰o_zero‰i‰w‰o";

add_rw_thms [lt‰i‰w‰o_SupIm‰o, lt‰i‰w‰o_SSupIm‰o, SupIm‰o_zero‰i‰w‰o, SSupIm‰o_zero‰i‰w‰o] "'u002";
add_sc_thms [lt‰i‰w‰o_SupIm‰o, lt‰i‰w‰o_SSupIm‰o, SupIm‰o_zero‰i‰w‰o, SSupIm‰o_zero‰i‰w‰o] "'u002";
add_st_thms [lt‰i‰w‰o_SupIm‰o, lt‰i‰w‰o_SSupIm‰o, SupIm‰o_zero‰i‰w‰o, SSupIm‰o_zero‰i‰w‰o] "'u002";
set_merge_pcs ["rbjmisc", "'u002"];
=TEX
}%ignore

\subsection{Defining Functions over Well Orderings}

Often functions over ordinals are defined by cases in a manner analogous to primitive recursive definitions over the natural numbers (in which the cases are zero and successors) by adding a further case for limit ordinals.

The approach I adopt addresses directly the limit case and subsumes the whole.

It may help to think of this as definition by inequality.
Just as sets can be uniquely determined by identifying their members, so can 'as when they are represented by sets.
Though we do not represent an 'a by a set, it is nevertheless uniquely determined by its predecessors, which would have been its members if we had been working in set theory.

Thus an 'a $Â$ might be defined by a sentence of the following form:

=GFT
	µÇ· Ç <‰i‰w‰o Â ¤ formula
=TEX	

I did look for a way of automatically proving the consistency of definitions in that form, but found this to be less straightforward than I had expected.
The reason is that not all formulae of the given form are consistent.
The formula on the right has to have the property that if true for a given value $Ç$ it is true also for any smaller value.

I have therefore to fall back on forms of definition more similar to those used in t042 \cite{rbjt042}.

Thus instead of the above we would have something like:

=GFT
	Â = SSup‰i‰w‰o {Ç | formula}
=TEX	

Which is not subject to the same constraint.

A further problem is the necessary recursion in defining operations over 'as.
A more definite example is desirable so we will look at addition.

Addition could be defined as follows:

=GFT
	µÂ Ç È· È <‰i‰w‰o Â +‰o Ç ¤ È <‰i‰w‰o Â ² ¶Ò· Ò <‰i‰w‰o Ç ± È = Â +‰o Ò
=TEX

The recursion here is well-founded because the addition on the right operates on smaller arguments than the one on the left.
To make this conspicuous we can rewrite the definition, first:

=GFT
	µÂ Ç· Â +‰o Ç = SSup‰i‰w‰o {È | È <‰i‰w‰o Â ² ¶Ò· Ò <‰i‰w‰o Ç ± È = Â +‰o Ò}
=TEX


This first step overcomes the first problem (the dependence on establishing that the formula `downward closed', the set in the second formulation does not need to be downward closed).
The smaller values become irrelevant, and this could be simplified to:

=GFT
	µÂ Ç· Â +‰o Ç = SSup‰i‰w‰o {È | ¶Ò· Ò <‰i‰w‰o Ç ± È = Â +‰o Ò}
=TEX

A further step allows the well-foundedness of the recursion to be made more obvious.

=GFT
	µÂ Ç· ($+‰o Â) Ç = SSup‰i‰w‰o (Image‰i‰w‰o ($+‰o Â) Ç)
=TEX

It is a feature of $SSupIm‰o (\$+‰o Â) Ç$ that it accessed values of $\$+‰o Â$ only for 'as less than $Ç$.
A suitable recursion theorem is necessary to permit definitions in this form to be accepted.

There is a question in formulating such a recursion theorem as to what access to the function is required.
A maximally general theorem will allow access to a restricted version of the function, an intermediate version to the image of the values below some 'a through the map, and a minimal version to the supremum of strict supremum of the values.
At this point it is not clear to me what is likely to be most useful.

On considering this I came to the conclusion that a general principle should be provided elsewhere, and have put one ($tf\_rec\_thm2$) in t009 \cite{rbjt009}.
This provides a recursion theorem for use with any well-founded relation.

When we specialise that to the ordering over the 'as we get:

=GFT
Ûlt‰i‰w‰o_rec_thmÝ =
	ô µ af· ¶ f· µ x· f x = af ((x, $<‰i‰w‰o) §ò f) x
=TEX

In which the operator $§ò$ restricts the domain of function $f$ hiding information about values for arguments not lower in the ordering than $x$.
This can be made a little slicker for use in this document by defining a more specific restriction operator:

=SML
declare_infix(400, "ò‰i‰w‰o");
=TEX

¹HOLCONST
Ü $Ûò‰i‰w‰oÝ: 'a ­ ('a ­ 'b) ­ ('a ­ 'b)
÷üüüüüüüüüüü
Ü µx f· x ò‰i‰w‰o f = (x, $<‰i‰w‰o) §ò f
°

=GFT
Ûò‰i‰w‰o_fcÝ =
	ô µÇ f Â· Â <‰i‰w‰o Ç ´ (Ç ò‰i‰w‰o f) Â = f Â
ÛImage‰i‰w‰o_ò‰i‰w‰o_thmÝ =
	ô µ Ç f· Image‰i‰w‰o (Ç ò‰i‰w‰o f, Ç) = Image‰i‰w‰o (f, Ç)
=IGN
ÛSupIm‰o_ò‰i‰w‰o_thmÝ =
	ô µ Ç f· SupIm‰o (Ç ò‰i‰w‰o f, Ç) = SupIm‰o (f, Ç)
ÛSSupIm‰o_ò‰i‰w‰o_thmÝ =
	ô µÇ f· SSupIm‰o (Ç ò‰i‰w‰o f, Ç) = SSupIm‰o (f, Ç)
=TEX

Hence:

=GFT
Ûlt‰i‰w‰o_rec_thm2Ý =
	ô µ af· ¶ f· µ x· f x = af (x ò‰i‰w‰o f) x
=TEX

Unfortunately this will not work with the ProofPower consistency prover, which requires a constructor (as if we were defining a function by pattern matching over a recursive data type).
To get automatic consistency proofs we need to add a dummy constructor, so:

=GFT
Ûlt‰i‰w‰o_rec_thm3Ý =
	ô µ af· ¶ f· µ x· f (CombI x) = af (x ò‰i‰w‰o f) x
=TEX

=GFT
ÛImage‰i‰w‰o_recursion_thmÝ =
	ô µ af· ¶ f· µ x· f (CombI x) = af (Image‰i‰w‰o (f, x)) x
=TEX


\ignore{
=SML
val ò‰i‰w‰o_def = get_spec ¬$ò‰i‰w‰o®;

set_goal([], ¬µÇ f Â· Â <‰i‰w‰o Ç ´ (Ç ò‰i‰w‰o f) Â = f Â®);
a (REPEAT µ_tac THEN rewrite_tac [ò‰i‰w‰o_def] THEN REPEAT strip_tac
	THEN FC_T rewrite_tac [§ò_fc_thm]); 
val ò‰i‰w‰o_fc = save_pop_thm "ò‰i‰w‰o_fc";

set_goal([], ¬µÇ f· Image‰i‰w‰o (Ç ò‰i‰w‰o f, Ç) = Image‰i‰w‰o (f, Ç)®);
a (REPEAT µ_tac THEN once_rewrite_tac [Image‰i‰w‰o_def]);
a (rewrite_tac [sets_ext_clauses]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (fc_tac [ò‰i‰w‰o_fc]);
a (¶_tac ¬È® THEN asm_rewrite_tac[]);
a (SYM_ASMS_T once_rewrite_tac);
a (rewrite_tac[]);
(* *** Goal "2" *** *)
a (fc_tac [ò‰i‰w‰o_fc]);
a (¶_tac ¬È® THEN asm_rewrite_tac[]);
val Image‰i‰w‰o_ò‰i‰w‰o_thm = save_pop_thm "Image‰i‰w‰o_ò‰i‰w‰o_thm";

=IGN
set_goal([], ¬µÇ f· SupIm‰o (Ç ò‰i‰w‰o f, Ç) = SupIm‰o (f, Ç)®);
a (REPEAT strip_tac THEN rewrite_tac [lt‰i‰w‰o_ext_thm]
	THEN REPEAT strip_tac
	THEN POP_ASM_T ante_tac
	THEN_TRY FC_T rewrite_tac [ò‰i‰w‰o_fc]
	THEN strip_tac
	THEN ¶_tac ¬È:'a®
	THEN REPEAT strip_tac
	);
a (FC_T asm_rewrite_tac [ò‰i‰w‰o_fc]);
val SupIm‰o_ò‰i‰w‰o_thm = save_pop_thm "SupIm‰o_ò‰i‰w‰o_thm";

set_goal([], ¬µÇ f· SSupIm‰o (Ç ò‰i‰w‰o f, Ç) = SSupIm‰o (f, Ç)®);
a (REPEAT strip_tac THEN rewrite_tac [lt‰i‰w‰o_ext_thm]
	THEN REPEAT strip_tac
	THEN POP_ASM_T ante_tac
	THEN_TRY FC_T rewrite_tac [ò‰i‰w‰o_fc]
	THEN strip_tac
	THEN ¶_tac ¬È:'a®
	THEN REPEAT strip_tac
	);
a (FC_T asm_rewrite_tac [ò‰i‰w‰o_fc]);
val SSupIm‰o_ò‰i‰w‰o_thm = save_pop_thm "SSupIm‰o_ò‰i‰w‰o_thm";

=SML
val lt‰i‰w‰o_rec_thm = save_thm("lt‰i‰w‰o_rec_thm",
	rewrite_rule [lt‰i‰w‰o_WFWO_thm] (µ_elim ¬$<‰i‰w‰o: 'b ­ 'b ­ BOOL® tf_rec_thm2));

set_goal([], ¬µ af· ¶ f:'a­'b· µ x· f x = af (x ò‰i‰w‰o f) x®);
a (rewrite_tac[ò‰i‰w‰o_def, lt‰i‰w‰o_rec_thm]);
val lt‰i‰w‰o_rec_thm2 = save_pop_thm "lt‰i‰w‰o_rec_thm2";

set_goal ([], ¬µ af· ¶ f· µ x· f (CombI x) = af (x ò‰i‰w‰o f) x®);
a (strip_tac);
a (strip_asm_tac (µ_elim ¬af® lt‰i‰w‰o_rec_thm2));
a (¶_tac ¬f® THEN asm_rewrite_tac [get_spec ¬CombI®]);
val lt‰i‰w‰o_rec_thm3 = save_pop_thm "lt‰i‰w‰o_rec_thm3";

(*
set_goal([], ¬µaf· (Ìf x· af (Image‰i‰w‰o (f, x)) x) respects $<‰i‰w‰o®);
a (rewrite_tac [get_spec ¬$respects®] THEN REPEAT strip_tac);
a (LEMMA_T ¬Image‰i‰w‰o (g, x) = Image‰i‰w‰o (h, x)® rewrite_thm_tac);
a (rewrite_tac[lt‰i‰w‰o_ext_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬È® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a (POP_ASM_T ante_tac);
a (lemma_tac ¬tc $<‰i‰w‰o È x® THEN1 fc_tac [tc_incr_thm]);
a (ASM_FC_T (rewrite_tac) []);
(* *** Goal "1.2" *** *)
a (POP_ASM_T ante_tac);
a (lemma_tac ¬tc $<‰i‰w‰o È x® THEN1 fc_tac [tc_incr_thm]);
a (ASM_FC_T rewrite_tac []);
(* *** Goal "2" *** *)
a (¶_tac ¬È® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a (POP_ASM_T ante_tac);
a (lemma_tac ¬tc $<‰i‰w‰o È x® THEN1 fc_tac [tc_incr_thm]);
a (ASM_FC_T rewrite_tac []);
(* *** Goal "2.2" *** *)
a (POP_ASM_T ante_tac);
a (lemma_tac ¬tc $<‰i‰w‰o È x® THEN1 fc_tac [tc_incr_thm]);
a (ASM_FC_T rewrite_tac []);
val Image‰i‰w‰o_respects_lt‰i‰w‰o = pop_thm ();
*)

=IGN
set_goal([], ¬µaf· (Ìf (x:'a)· af (Image‰i‰w‰o (f, x)) x) respects $<‰i‰w‰o®);
a (rewrite_tac [get_spec ¬$respects®] THEN REPEAT strip_tac);
a (LEMMA_T ¬Image‰i‰w‰o (g, x) = Image‰i‰w‰o (h, x)® rewrite_thm_tac);
a (rewrite_tac[lt‰i‰w‰o_ext_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬È® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a (POP_ASM_T ante_tac);
a (lemma_tac ¬tc $<‰i‰w‰o È x® THEN1 fc_tac [tc_incr_thm]);
a (ASM_FC_T (rewrite_tac o list_map_eq_sym_rule) []);
(* *** Goal "2" *** *)
a (¶_tac ¬È® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a (POP_ASM_T ante_tac);
a (lemma_tac ¬tc $<‰i‰w‰o È x® THEN1 fc_tac [tc_incr_thm]);
a (ASM_FC_T rewrite_tac []);
val Image‰i‰w‰o_respects_lt‰i‰w‰o = pop_thm ();

set_goal([], ¬µ af· ¶ f· µx:'a· f (CombI x) = af (Image‰i‰w‰o (f, x)) x®);
a (REPEAT strip_tac THEN_TRY rewrite_tac[get_spec ¬CombI®]);
a (¶_tac ¬fix (Ìf x· af (Image‰i‰w‰o (f, x)) x)®);
a (asm_tac Image‰i‰w‰o_respects_lt‰i‰w‰o);
a (asm_tac lt‰i‰w‰o_wf);
a (spec_nth_asm_tac 2 ¬af®);
a (all_fc_tac [get_spec ¬fix®]);
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac[ext_thm]);
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac []);
val Image‰i‰w‰o_recursion_thm = save_pop_thm "Image‰i‰w‰o_recursion_thm";
=TEX
}%ignore

Rather than having specific recursion theorems for definitions involving SupIm or SSupIm, we apply the required domain restriction to the function being defined wherever it is used on the right of the definition.

=SML
force_new_pc "'u002-rec1";
add_¶_cd_thms [lt‰i‰w‰o_rec_thm3] "'u002-rec1";
=TEX

\subsection{Defining Inaccessibility}

The significance of this section to the purposes of this work is moot, since the strong axiom of infinity, which implicitly asserts the existence of inaccessible 'a ordinals, does not depend upon an explicit definition.

The purpose of this section is therefore as a kind of check on the formulation of that axiom.
This check could go as far as defining inaccessible and proving the equivalence of the give axiom with a formulation based on the defined concept.
However, to serve that pupose this material would have to come before the axiom, since in the context of that axiom we cannot distinguish between equivalence and entailment of the new formulation by the old.

Co-finality is usually a relation between increasing $Â$ sequences (Â a limit 'a) and some limit 'a $Á$.
I don't yet have sequences, so its convenient to give a slightly broader definition.
Instead of increasing sequences I allow the image of any 'a under a function (which need not be increasing).
At this point I don't actually understand why (or if) an increasing sequence is neeeded.

Such an image is ``cofinal'' in an 'a if:

\begin{itemize}
\item the image falls entirely below the 'a
\item the supremum of the image is that 'a
\end{itemize}

=SML
declare_infix(400, "CofinalIn‰i‰w‰o");
=TEX

A the image of an ordinal in a function is cofinal in some ordinal if that ordinal is the strict supremum of the image of the first ordinal through the function.

¹HOLCONST
Ü $ÛCofinalIn‰i‰w‰oÝ: (('a ­ 'a) ¸ 'a) ­ 'a ­ BOOL
÷üüüüüüüüüüü
Ü µx Ç· x CofinalIn‰i‰w‰o Ç ¤ Image‰i‰w‰o x € X‰i‰w‰o Ç ± SupIm‰i‰w‰o x = Ç 
°

The cofinality of an ordinal is the least ordinal cofinal in that ordinal through some function.

¹HOLCONST
Ü ÛCf‰i‰w‰oÝ: 'a ­ 'a
÷üüüüüüüüüüü
Ü µÂ· Cf‰i‰w‰o Â = Least‰i‰w‰o {Ç | ¶f· (f, Ç) CofinalIn‰i‰w‰o Â}
°

We can now define the notion of regularity, one of the defining properties of inaccessible cardinals.

¹HOLCONST
Ü ÛRegular‰i‰w‰oÝ: 'a ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· Regular‰i‰w‰o Â ¤ Cf‰i‰w‰o Â = Â
°

Though in general we are talking here of properties of ordinals, a regular ordinal must be a cardinal.

¹HOLCONST
Ü ÛSingular‰i‰w‰oÝ: 'a ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· Singular‰i‰w‰o Â ¤ ³ Regular‰i‰w‰o Â
°

As well as using this in the definition of inaccessibility we want to be able to state that the universe is regular (to get sufficiently generous recursion principles, analogous to global replacement).
The vocabulary above doesn't really help in stating this global principle, but it is simple enough to state directly.
We will come to that later.

To get inaccessibilty we need also to express the notion of a strong limit.

¹HOLCONST
Ü ÛSucc‰i‰w‰oÝ: 'a ­ 'a
÷üüüüüüüüüüü
Ü µÂ· Succ‰i‰w‰o Â = Least‰i‰w‰o {Ç | Â <‰i‰w‰o Ç}
°

¹HOLCONST
Ü ÛSuccessor‰i‰w‰oÝ: 'a ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· Successor‰i‰w‰o Â ¤ ¶Ç· Â = Succ‰i‰w‰o Ç
°

¹HOLCONST
Ü ÛLimit‰i‰w‰oÝ: 'a ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· Limit‰i‰w‰o Â ¤ 0‰i‰w‰o <‰i‰w‰o Â ± ³ Successor‰i‰w‰o Â
°

¹HOLCONST
Ü Û×‰i‰w‰oÝ: 'a
÷üüüüüüüüüüü
Ü ×‰i‰w‰o = Least‰i‰w‰o {Â | Limit‰i‰w‰o Â}
°

=GFT
=TEX

\ignore{
=SML
val Succ‰i‰w‰o_def = get_spec ¬Succ‰i‰w‰o®;
val Successor‰i‰w‰o_def = get_spec ¬Successor‰i‰w‰o®;
val Limit‰i‰w‰o_def = get_spec ¬Limit‰i‰w‰o®;
val ×‰i‰w‰o_def = get_spec ¬×‰i‰w‰o®;

=IGN
set_goal([], ¬Limit‰i‰w‰o ×‰i‰w‰o ± µÂ· Limit‰i‰w‰o Â ´ ×‰i‰w‰o ¼‰i‰w‰o Â®);
a (rewrite_tac[×‰i‰w‰o_def]);

=TEX
}%ignore

¹HOLCONST
Ü ÛStrongLimit‰i‰w‰oÝ: 'a ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· StrongLimit‰i‰w‰o Â ¤ µÇ· Ç <‰i‰w‰o Â ´ ð (X‰i‰w‰o Ç) <‰s X‰i‰w‰o Â
°

¹HOLCONST
Ü ÛInaccessible‰i‰w‰oÝ: 'a ­ BOOL
÷üüüüüüüüüüü
Ü µÂ· Inaccessible‰i‰w‰o Â ¤ Regular‰i‰w‰o Â ± StrongLimit‰i‰w‰o Â
°

A strong axiom of infinity can now be expressed thus:

=SML
val strong_infinity2 = ¬
µÂ· 	(¶Ç· Â <‰i‰w‰o Ç ± Inaccessible‰i‰w‰o Ç)
    ±
	(µf· (¶Ò· (µÎ· Î <‰i‰w‰o Â ´ f Î <‰i‰w‰o Ò)))
®;
=TEX

The first clause states that every element is less than some inaccessible, but does not state that the universe is inaccessible.
It does entail that the universe is a strong limit cardinal.
The second clause asserts that the universe is also regular and hence inacessible.
We can't use the concept definitions given above for talking about the universe, since they are properties of elements.
I could have expressed them as properties of sets of elements, perhaps that would have been better?

\ignore{
=SML

val CofinalIn‰i‰w‰o_def = get_spec ¬$CofinalIn‰i‰w‰o®;
val Cf‰i‰w‰o_def = get_spec ¬Cf‰i‰w‰o®;
val Regular‰i‰w‰o_def = get_spec ¬Regular‰i‰w‰o®;
val StrongLimit‰i‰w‰o_def = get_spec ¬StrongLimit‰i‰w‰o®;
=TEX
}%ignore

\section{THE many TYPE CONSTRUCTOR and STRONG INFINITY}

=SML
open_theory "u002";
force_new_theory "ÛmanyÝ";
new_parent "U_orders";
new_parent "trees";
new_parent "wf_relp";
new_parent "wf_recp";
force_new_pc "Û'manyÝ";
merge_pcs ["'savedthm_cs_¶_proof"] "'many";
set_merge_pcs ["rbjmisc", "'many"];
=TEX


=SML
new_type ("many", 1);
=TEX

The purpose of the type parameter is to allow a strict lower bound to be placed on the cardinality of the type.
This is necessary for support of polymorphic datatypes, since otherwise, however large the type of \emph{'a many} the polymorphic datatype could be instantiated to a size larger than the \emph{'a many} by supplying the \emph{'a many} as a type parameter.

The desired effect is as given by the following axiom:

=SML
val card_slb = new_axiom(["card_slb"], ¬
	(Universe:'a SET) <‰s (Universe:'a many SET)
®);
=TEX

The strong infinity axiom is then:

=SML
val strong_infinity = new_axiom(["strong_infinity"], ¬
µÂ·
	¶Ç· Â <‰i‰w‰o Ç
±
	µÔ· Ô <‰i‰w‰o Ç ´ 
	   ð (X‰i‰w‰o Ô) <‰s X‰i‰w‰o Ç
	± (µf· (¶Ò· (µÎ· Î <‰i‰w‰o Ô ´ f Î <‰i‰w‰o Ò) ±
			(Ò ¼‰i‰w‰o Ç ´ Ò <‰i‰w‰o Ç)))
	
®);
=TEX


The axiom is intended to state:
\begin{enumerate}
\item that every element is less than some ``inaccessible element''
\item that the universe is the set of elements less than some regular element
\end{enumerate}

Thus $Ç$ in the axiom is the name used for this supposedly inaccessible element, but note that the least such $Ç$ will not be inaccessible, but will be $×$, the first limit 'a.
Adding the requirement that $Ç$ be uncountable does not strengthen the axiom which still entails that every 'a is less than some inaccessible 'a.
What we assert of $Ç$ is first that it is a strong limit 'a and then that it (and the universe as a whole) is regular.
These concepts are given formal definitions later, but the axiom is presented in concise form rather than through the definitions of the concepts.

It will be a while before any use is made of this axiom at all.

\ignore{
=IGN
(* The following requires strong infinity. *)

set_goal([], ¬µf (Â:'a)· ¶Ç:'a· Ç  Ub‰i‰w‰o(Image‰i‰w‰o (f, Â))®);
a (REPEAT µ_tac);
a (strip_asm_tac (strong_infinity));
a (spec_nth_asm_tac 1 ¬Â:'a®);
a (spec_nth_asm_tac 1 ¬Â®);
a (SPEC_NTH_ASM_T 1 ¬f® (STRIP_THM_THEN (STRIP_THM_THEN asm_tac)));
a (POP_ASM_T discard_tac);
a (rewrite_tac[Ub‰i‰w‰o_def]);
a (¶_tac ¬Ò®
	THEN rewrite_tac[Image‰i‰w‰o_thm]
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[¼‰i‰w‰o_def]
	THEN asm_fc_tac[]
	THEN contr_tac);
val Ub‰i‰w‰o_Image‰i‰w‰o_thm = save_pop_thm "Ub‰i‰w‰o_Image‰i‰w‰o_thm";

set_goal([], ¬µf Â Ç· Ç  Ub‰i‰w‰o(Image‰i‰w‰o (f, 0‰i‰w‰o))®);
a (rewrite_tac[Ub‰i‰w‰o_thm, Ub‰i‰w‰o_Image‰i‰w‰o_thm, Image‰i‰w‰o_zero‰i‰w‰o_thm]);
val Ub‰i‰w‰o_Image‰i‰w‰o_zero‰i‰w‰o = save_pop_thm "Ub‰i‰w‰o_Image‰i‰w‰o_zero‰i‰w‰o";

set_goal([], ¬µf (Â:'a)· ¶Ç:'a· Ç  SUb‰i‰w‰o(Image‰i‰w‰o (f, Â))®);
a (REPEAT µ_tac);
a (strip_asm_tac (strong_infinity));
a (spec_nth_asm_tac 1 ¬Â®);
a (spec_nth_asm_tac 1 ¬Â®);
a (SPEC_NTH_ASM_T 1 ¬f® (STRIP_THM_THEN (STRIP_THM_THEN asm_tac)));
a (POP_ASM_T discard_tac);
a (rewrite_tac[SUb‰i‰w‰o_def]);
a (¶_tac ¬Ò®
	THEN rewrite_tac[Image‰i‰w‰o_thm]
	THEN REPEAT strip_tac
	THEN asm_rewrite_tac[¼‰i‰w‰o_def]
	THEN asm_fc_tac[]
	THEN contr_tac);
val SUb‰i‰w‰o_Image‰i‰w‰o_thm = save_pop_thm "SUb‰i‰w‰o_Image‰i‰w‰o_thm";

set_goal([], ¬µf Â Ç· Ç  SUb‰i‰w‰o(Image‰i‰w‰o (f, 0‰i‰w‰o))®);
a (rewrite_tac[SUb‰i‰w‰o_Image‰i‰w‰o_thm, Image‰i‰w‰o_zero‰i‰w‰o_thm]);
val SUb‰i‰w‰o_Image‰i‰w‰o_zero‰i‰w‰o = save_pop_thm "SUb‰i‰w‰o_Image‰i‰w‰o_zero‰i‰w‰o";

add_rw_thms [Image‰i‰w‰o_thm, zero‰i‰w‰o_thm, lt‰i‰w‰o_zero‰i‰w‰o_thm, Ub‰i‰w‰o_Image‰i‰w‰o_zero‰i‰w‰o,
	SUb‰i‰w‰o_Image‰i‰w‰o_zero‰i‰w‰o] "'u002";
add_sc_thms [Image‰i‰w‰o_thm, zero‰i‰w‰o_thm, lt‰i‰w‰o_zero‰i‰w‰o_thm, Ub‰i‰w‰o_Image‰i‰w‰o_zero‰i‰w‰o,
	SUb‰i‰w‰o_Image‰i‰w‰o_zero‰i‰w‰o] "'u002";
add_st_thms [Image‰i‰w‰o_thm, lt‰i‰w‰o_zero‰i‰w‰o_thm] "'u002";
set_merge_pcs ["rbjmisc", "'u002"];

set_goal([], ¬µf Â Ç· Ç <‰i‰w‰o SupIm‰i‰w‰o (f, Â) ¤ ¶È· È <‰i‰w‰o Â ± Ç <‰i‰w‰o f È®);
a (REPEAT µ_tac
	THEN rewrite_tac [SupIm‰i‰w‰o_def]);
a (strip_asm_tac (list_µ_elim [¬f®, ¬Â®] Ub‰i‰w‰o_Image‰i‰w‰o_thm));
a (all_ufc_¤_rewrite_tac [µ_elim ¬Image‰i‰w‰o (f, Â)® lt‰i‰w‰o_Sup‰i‰w‰o]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (¶_tac ¬$"È'"® THEN asm_rewrite_tac[]);
a (SYM_ASMS_T rewrite_tac);
(* *** Goal "2" *** *)
a (¶_tac ¬f È® THEN asm_rewrite_tac[Image‰i‰w‰o_thm]);
a (¶_tac ¬È® THEN asm_rewrite_tac[]);
val lt‰i‰w‰o_SupIm‰i‰w‰o = save_pop_thm "lt‰i‰w‰o_SupIm‰i‰w‰o";

set_goal([], ¬µf Â Ç· ³ Ç <‰i‰w‰o SupIm‰o (f, 0‰i‰w‰o)®);
a (rewrite_tac[lt‰i‰w‰o_SupIm‰o]);
val SupIm‰o_zero‰i‰w‰o = save_pop_thm "SupIm‰o_zero‰i‰w‰o";
=TEX
}%ignore

\appendix

{\raggedright
\bibliographystyle{fmu}
\bibliography{rbj,fmu}
} %\raggedright

{\let\Section\section
\newcounter{ThyNum}
\def\section#1{\Section{#1}
\addtocounter{ThyNum}{1}\label{Theory\arabic{ThyNum}}}
\include{many.th}
}%\let

\twocolumn[\section{INDEX}\label{index}]
{\small\printindex}

\end{document}
